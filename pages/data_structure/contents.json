[{"slug":"LC-49:Group-Anagrams","published":"2022-12-26","updated":"2022-12-26","body":"<h1 id=\"topic\">Topic:</h1>\n<p><em>Hashmap, String Manipulation, Array, Sorting</em></p>\n<hr>\n<p>Leetcode question goes the following:</p>\n<p><img src=\"https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/60bb6b64-95a7-481e-8c9f-fdcf6e2e6270/dfl55i0-f00d4a1d-0c64-4d0c-b3ee-e55e57b41ea8.png/v1/fill/w_1280,h_1020,q_80,strp/group_anagrams_by_jimjet123_dfl55i0-fullview.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MTAyMCIsInBhdGgiOiJcL2ZcLzYwYmI2YjY0LTk1YTctNDgxZS04YzlmLWZkY2Y2ZTJlNjI3MFwvZGZsNTVpMC1mMDBkNGExZC0wYzY0LTRkMGMtYjNlZS1lNTVlNTdiNDFlYTgucG5nIiwid2lkdGgiOiI8PTEyODAifV1dLCJhdWQiOlsidXJuOnNlcnZpY2U6aW1hZ2Uub3BlcmF0aW9ucyJdfQ.yVCX5fm5ALRsm_Ri4Az0W-VdJIyXUG3NYIAkX_SHNbI\" alt=\"alt.text\" title=\"just testing~\"></p>\n<p>This is an &quot;upgraded&quot; version of the classic <em>anagram</em> problem where you compare strings and see if they are anagrams of each other.</p>\n<p>But this time, you&#39;re asked to sort all <em>possible anagram groups</em> into their <em>separate sub-array</em>.</p>\n<p>So let&#39;s get down to the <em>basics</em> first: </p>\n<h1 id=\"what-is-an-anagram\"><em>what is an anagram?</em></h1>\n<p>Simply put, an anagram is a <em>collection of words</em> that when we <em>rearrange the individual letters</em> in any <em>word</em> will result in <em>another</em> word.</p>\n<p>So for example, we&#39;d have <em>&quot;ate&quot; === &quot;eat&quot;</em> as an example of anagrams group. other examples include:</p>\n<ol>\n<li><em>&quot;Fried&quot; === &quot;Fired&quot;</em></li>\n<li><em>&quot;Gainly&quot; === &quot;Laying&quot;</em></li>\n<li><em>&quot;Sadder&quot; === &quot;Dreads&quot;</em></li>\n<li><em>&quot;Listen&quot; === &quot;Silent&quot;</em></li>\n</ol>\n<p>It&#39;s worth pointing out that they aren&#39;t necessarily <em>pairs</em>, 3 words or more anagram groups do exist out there such as:</p>\n<ul>\n<li><em>&quot;ANEW&quot;</em> === <em>&quot;WANE&quot;</em> === <em>&quot;WEAN&quot;</em></li>\n</ul>\n<hr>\n<h2 id=\"back-to-the-problem\">Back to the problem.</h2>\n<h3 id=\"input-and-output\">Input and Output:</h3>\n<p>we are given an array that contains string elements within it:</p>\n<pre><code class=\"language-py\">    strs = [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]\n</code></pre>\n<p>From this <em>input</em> we are asked to sort all the anagram groups that exists within the array into sub-arrays. \nTaken into practice, it would look something like this.</p>\n<pre><code class=\"language-py\">    Output = [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]\n</code></pre>\n<h3 id=\"contrainsts\">Contrainsts</h3>\n<ul>\n<li>1 &lt;= *strs.length* &lt;= 104  -&gt; <strong>the length of input is between 1 to 104 elements.</strong></li>\n<li>0 &lt;= *strs[i].length* &lt;= 100 -&gt; <strong>each individual string are between 0 to 100 length.</strong></li>\n<li><em>strs[i]</em> consists of lowercase English letters.</li>\n</ul>\n<p>The only constraint we realistically care for is the last point. The letters will only be in <em>lowercase English letters</em>. \nHold that information in mind, it will come up later.</p>\n<p>We&#39;re done with <em>explaination</em>, let&#39;s get into <em>solution analysis</em>. </p>\n<hr class=\"mt-4 mb-4\"/>\n\n<h3 id=\"the-fools-approach\">The Fool&#39;s Approach</h3>\n<p>so, let&#39;s first think of the solution on our own, what would be the most obvious solution that many would come up with?</p>\n<p>-First obvious observation, anagrams must contain the same length of letters.</p>\n<p>-Second, when sorted all the letters in order of a-z --&gt;they should be exactly identical. example, <em>&quot;ate&quot; and &quot;eat&quot;</em> when sorted -&gt; <em>&quot;aet&quot;</em></p>\n<p>--&gt; So we can go through all the elements in the array <em>then</em> sort the letters <em>then</em> compare and <em>then</em> group them together. </p>\n<p>Doesn&#39;t sound like a bad idea right? let&#39;s see this &quot;algorithm&quot; in action below:</p>\n<p><img src=\"https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/60bb6b64-95a7-481e-8c9f-fdcf6e2e6270/dfl5c2o-ecdb3206-2798-4e6c-81f1-d28b02652787.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiJcL2ZcLzYwYmI2YjY0LTk1YTctNDgxZS04YzlmLWZkY2Y2ZTJlNjI3MFwvZGZsNWMyby1lY2RiMzIwNi0yNzk4LTRlNmMtODFmMS1kMjhiMDI2NTI3ODcucG5nIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.dkfaOdSWXBPxNul5ckpLPtmhnBMu3vYPzI35pKmJspA\" alt=\"alt.text\" title=\"just testing~\"></p>\n<p>In this <strong>particular input</strong>, the first loop will give us <em><code>[&quot;eat&quot;, &quot;tea&quot;, &quot;ate&quot;]</code></em>, then the 2nd will give us <em><code>[&quot;tan&quot;,&quot;nat&quot;]</code></em> then finally <em><code>[&quot;bat&quot;]</code></em></p>\n<p>so we&#39;d ended up performing <em>3</em> loops just to achieve the ideal output. doesn&#39;t seem that bad right?</p>\n<p><em>BUTTTTTT</em>, to quote <a href=\"https://youtu.be/oAHbLRjF0vo\">CGP Grey</a>:</p>\n<pre><code>    Solutions that are:\n    1. First thing you think of\n    2. Looks Sensible\n    3. Easy to implement\n    ----\n    Are often: \n    1. Terrible.\n    2. Ineffective Solutions.\n    3. Will cause suffering.\n    4. Why are we made to suffer?\n</code></pre>\n<h3 id=\"so-why-is-this-solution-bad\">So why is this solution bad?</h3>\n<p><strong>Answer: most sorting algorithm takes <em>O(nlogn)</em> in time complexity.</strong></p>\n<p>Complexity analysis of this solution: </p>\n<p><strong>The above approach yields us <em>O(m * nlog(n))</em> in time but <em>O(n)</em> in space complexity</strong></p>\n<p><em>m</em> here is the number of input strings given to us. </p>\n<p>That is HELLA slow.</p>\n<p>Let&#39;s think of the <strong>absolute worst scenario</strong> for this solution, what if all the individual words are their own unique Anagram?</p>\n<p>Then we&#39;d have to sort each individual words (<em>m</em>) with <em>O(nlog(n))</em> complexity. within low length input, this might be acceptable. However, as the length of both Array and then individual words grow, this solution will be <em>very very verrrry slow.</em></p>\n<p>Here&#39;s a handy visualization for big O categorization:</p>\n<p><img src=\"https://qph.cf2.quoracdn.net/main-qimg-22c307bb694f518b82c515cd12c24920\" alt=\"alt.text\" title=\"just testing~\">\nso obviously, <em>O(nlog(n))</em> isn&#39;t the <em>worst</em> but it ain&#39;t that good too. so how can we improve on this?</p>\n<h2 id=\"a-better-solution\">A better solution</h2>\n<h3 id=\"part-1-comparison\">part 1: Comparison</h3>\n<p>A faster way to compare the strings without resorting to sorting would be creating an array that counts the number individual letters. (stay with me, it&#39;ll make sense soon)</p>\n<p>so imagine the array below with each element represent the <em>number of letters</em> in a particular word:</p>\n<pre><code class=\"language-py\">count = [0 ,0 ,0 ,0 ,0, 0,0,0,0,0,0,0,...]\n</code></pre>\n<p>if the word was... <strong>&quot;bad&quot;</strong> then the <em>count</em> array would be:</p>\n<pre><code class=\"language-py\">count =[1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,...]\n</code></pre>\n<p>But how long should this count array be in order to represent any words that the test throws our way? </p>\n<p>think back to the constraints, we are given only <em>lowercase</em> words so therefore the count array should be in 26 range representing all lowercase letters.</p>\n<p>now if we use these array representation of words and compare them to each other, the comparison operation should take only O(n) each time.</p>\n<p>ok we solved the pesky comparison problem, now how do we store these information effectively on each iteration?</p>\n<h3 id=\"enter-hashmap\">Enter HashMap</h3>\n<p>I won&#39;t go into details on Hashmap as a data structure put simply put <strong><em>hashmaps</em> are used to store key-value pairs for efficient retrieval.</strong></p>\n<p>So let&#39;s say we create a hashmap that <em>stores</em> the <em>key</em> as the count and the value would be the array of anagramtic(?) words</p>\n<pre><code class=\"language-py\">Hmap = {\n    [1,1,0,1,0,0,0,...]: [&#39;Bad&#39;],\n    [1,0,0,1,0,...]: [&#39;ate&#39;,&#39;eat&#39;]\n}\n</code></pre>\n<p>After inputting into <em>Hashmap</em>, we simply only have to return all the <em>values</em> then we&#39;d have our answer :).</p>\n<h3 id=\"the-code\">The code:</h3>\n<pre><code class=\"language-py\">def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:\n    res = defaultdict(list); #ignore the python jibber jabber, here we&#39;re just initializing the Hmap\n    for s in strs:\n        count = [0] * 26 \n        for c in s:\n            count[ord(c)- ord(&#39;a&#39;)] +=1 #ord built-in function calculates the unicode value of the character \n                                        # so --&gt; unicode val of character - unicode of a gives the alphabetical order\n        res[tuple(count)].append(s) #tuple is sub-array, again python syntax\n    return res.values()\n</code></pre>\n<p>This solution gives us <strong>O(n * m * 26 )</strong> which is essentially <strong>O(n * m)</strong> both space and time complexity</p>\n<p>Much faster than the &quot;simple&quot; method.</p>\n<p>Anyway, that&#39;s all see ya!</p>\n","readingTime":7,"title":"Leet Code 49: Group Anagrams","tagline":"String manipulation, HashMap"}]